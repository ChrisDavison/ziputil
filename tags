!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	h,hashtag	/hashtags/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_KIND_DESCRIPTION!Rust	C,constant	/A constant/
!_TAG_KIND_DESCRIPTION!Rust	M,macro	/Macro Definition/
!_TAG_KIND_DESCRIPTION!Rust	P,method	/A method/
!_TAG_KIND_DESCRIPTION!Rust	c,implementation	/implementation/
!_TAG_KIND_DESCRIPTION!Rust	e,enumerator	/An enum variant/
!_TAG_KIND_DESCRIPTION!Rust	f,function	/Function/
!_TAG_KIND_DESCRIPTION!Rust	g,enum	/Enum/
!_TAG_KIND_DESCRIPTION!Rust	i,interface	/trait interface/
!_TAG_KIND_DESCRIPTION!Rust	m,field	/A struct field/
!_TAG_KIND_DESCRIPTION!Rust	n,module	/module/
!_TAG_KIND_DESCRIPTION!Rust	s,struct	/structural type/
!_TAG_KIND_DESCRIPTION!Rust	t,typedef	/Type Alias/
!_TAG_KIND_DESCRIPTION!Rust	v,variable	/Global variable/
!_TAG_KIND_DESCRIPTION!Yaml	a,anchor	/anchors/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!Make	0.0	/current.age/
!_TAG_PARSER_VERSION!Markdown	1.1	/current.age/
!_TAG_PARSER_VERSION!Rust	0.0	/current.age/
!_TAG_PARSER_VERSION!Yaml	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/Users/davison/code/ziputil/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	//
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
!_TAG_ROLE_DESCRIPTION!Yaml!anchor	alias	/alias/
AUTHORS	doc/ziputil.1.md	/^# AUTHORS$/;"	c
BIN_LINUX	Makefile	/^BIN_LINUX:=target\/${TARGET_LINUX}\/release\/${BIN_NAME}$/;"	m
BIN_NAME	Makefile	/^BIN_NAME:=$(shell grep name Cargo.toml | sed -e 's\/.* = "\\(.*\\)"\/\\1\/')$/;"	m
BIN_WIN	Makefile	/^BIN_WIN:=target\/${TARGET_WIN}\/release\/${BIN_NAME}.exe$/;"	m
COMMANDS	doc/ziputil.1.md	/^# COMMANDS$/;"	c
Choose	src/command.rs	/^    Choose,$/;"	e	enum:Command
Choose	src/main.rs	/^    Choose(CommonArgs),$/;"	e	enum:OptCommand
Command	src/command.rs	/^impl Command {$/;"	c
Command	src/command.rs	/^pub enum Command {$/;"	g
CommonArgs	src/main.rs	/^struct CommonArgs {$/;"	s
EXCLUDES	src/filter.rs	/^const EXCLUDES: [&str; 4] = [$/;"	C
Extract	src/command.rs	/^    Extract,$/;"	e	enum:Command
Extract	src/main.rs	/^    Extract(CommonArgs)$/;"	e	enum:OptCommand
Filter	src/filter.rs	/^impl Filter {$/;"	c
Filter	src/filter.rs	/^pub struct Filter {$/;"	s
List	src/command.rs	/^    List,$/;"	e	enum:Command
List	src/main.rs	/^    List(CommonArgs),$/;"	e	enum:OptCommand
NAME	doc/ziputil.1.md	/^# NAME$/;"	c
OPTIONS	doc/ziputil.1.md	/^# OPTIONS$/;"	c
OptCommand	src/main.rs	/^enum OptCommand {$/;"	g
Opts	src/main.rs	/^struct Opts {$/;"	s
SRC	Makefile	/^SRC=$(wildcard **\/*.rs)$/;"	m
SYNOPSIS	doc/ziputil.1.md	/^# SYNOPSIS$/;"	c
TARGET_LINUX	Makefile	/^TARGET_LINUX:=x86_64-unknown-linux-gnu$/;"	m
TARGET_WINDOWS	Makefile	/^TARGET_WINDOWS:=x86_64-pc-windows-gnu$/;"	m
VERSION	Makefile	/^VERSION:=$(shell grep version Cargo.toml | sed -e 's\/.* = "\\(.*\\)"\/\\1\/' | head -n1)$/;"	m
View	src/command.rs	/^    View,$/;"	e	enum:Command
View	src/main.rs	/^    View(CommonArgs),$/;"	e	enum:OptCommand
any	src/filter.rs	/^    any: bool,$/;"	m	struct:Filter
any	src/main.rs	/^        any: bool,$/;"	m	struct:CommonArgs
anymatch	src/filter.rs	/^    fn anymatch(&self, string: &str) -> bool {$/;"	P	implementation:Filter
build	Makefile	/^build: build_linux build_windows$/;"	t
build_linux	Makefile	/^build_linux: ${SRC}$/;"	t
build_linux_release	Makefile	/^build_linux_release: ${SRC}$/;"	t
build_windows	Makefile	/^build_windows: ${SRC}$/;"	t
build_windows_release	Makefile	/^build_windows_release: ${SRC}$/;"	t
check	Makefile	/^check: ${SRC}$/;"	t
choose_from_vector	src/utility.rs	/^pub fn choose_from_vector(vector: &[String]) -> Result<Vec<String>> {$/;"	f
command	src/main.rs	/^    command: OptCommand,$/;"	m	struct:Opts
command	src/main.rs	/^mod command;$/;"	n
display_files	src/utility.rs	/^pub fn display_files(zipfile: &std::path::PathBuf, names: &[String]) -> Result<()> {$/;"	f
display_matches	src/command.rs	/^    fn display_matches(matches: &[String]) -> Result<()> {$/;"	P	implementation:Command
execute	src/command.rs	/^    pub fn execute(&self, matches: &[String], zipfile: &PathBuf) -> Result<()> {$/;"	P	implementation:Command
extract_files	src/utility.rs	/^pub fn extract_files(zipfile: &std::path::PathBuf, names: &[String], outdir: &Path) -> Result<()/;"	f
filter	src/main.rs	/^mod filter;$/;"	n
filter_zip_by_name	src/filter.rs	/^    pub fn filter_zip_by_name(&self, zipfile: &std::path::PathBuf) -> Result<Option<Vec<String>>/;"	P	implementation:Filter
fuzzymatch	src/filter.rs	/^    fn fuzzymatch(&self, string: &str) -> bool {$/;"	P	implementation:Filter
get_number_choices	src/utility.rs	/^fn get_number_choices() -> Result<Vec<usize>> {$/;"	f
install	Makefile	/^install: ${SRC}$/;"	t
main	src/main.rs	/^fn main() {$/;"	f
matches	src/filter.rs	/^    pub fn matches(&self, string: &str) -> bool {$/;"	P	implementation:Filter
new	src/filter.rs	/^    pub fn new(any: bool, ordered: bool, query: Vec<String>) -> Filter {$/;"	P	implementation:Filter
not_excluded	src/filter.rs	/^    fn not_excluded(&self, string: &str) -> bool {$/;"	P	implementation:Filter
ordered	src/filter.rs	/^    ordered: bool,$/;"	m	struct:Filter
ordered	src/main.rs	/^        ordered: bool,$/;"	m	struct:CommonArgs
parse_range	src/utility.rs	/^fn parse_range(s: &str) -> Result<Vec<usize>> {$/;"	f
query	src/filter.rs	/^    query: Vec<String>,$/;"	m	struct:Filter
query	src/main.rs	/^        query: Vec<String>,$/;"	m	struct:CommonArgs
read_from_stdin	src/utility.rs	/^fn read_from_stdin(prompt: &str) -> Result<String> {$/;"	f
release	Makefile	/^release:$/;"	t
utility	src/main.rs	/^mod utility;$/;"	n
zipfile	src/main.rs	/^        zipfile: std::path::PathBuf,$/;"	m	struct:CommonArgs
ziputil	README.md	/^# ziputil$/;"	c
